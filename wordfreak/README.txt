For the BST in my implementation, I made the bst.c and its header file bst.h. In the source code for the BST, the two most important functions are the add_word() function and the bst_to_array() functions. The add_word() takes a char* and struct BST* of the root. It does an inorder traversal of the given BST and then creates a new BST node or increments the count if it already exists in the tree. For bst_to_array(), it takes in an empty array of struct BST* and a struct BST* of the root, and it does an inorder traversal of the root and adds the nodes into the array. This creates an array of all of the words in the tree in alphabetical order.

Wordfreak.c contains the main method for my implementation. It also contains the “hash function,” but under the name index_of_letter(). It takes in the 1st letter of the word that is being inserted and depending on whether the letter is lowercase or uppercase, it will subtract ‘a’ or ‘A’ from the letter, giving the correct index in the array of 26 BSTs assuming that they are in alphabetical order (BST for ‘a’ is at index 0). 

Wordfreak.c also contains the most important methods in my implementation: process_file() and its helper function process_string(). The first function, process_file() takes a file path and it then opens that file and handles the reading of the file. It then has a ‘buf’ buffer that gets read into from the file, as well as ‘contents’ and ‘remainder’ buffers. The ‘contents’ string contains everything in ‘remainder’ then everything in ‘buf’. The idea for this is that once when we are parsing the ‘contents’ string, once we get within MAX_WORD_LEN (100) characters from the end of ‘contents’, we want to store from the first non-alphabet character in that range to the end into ‘remainder’. This ‘remainder’ gets added to the next ‘contents’ string during the next read call. This way we do not cut off any words when parsing. More details in code comments.

Video demonstration: https://vimeo.com/501278003